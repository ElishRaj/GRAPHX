"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AtomMap_exports = {};
__export(AtomMap_exports, {
  AtomMap: () => AtomMap
});
module.exports = __toCommonJS(AtomMap_exports);
var import_state = require("@tldraw/state");
var import_utils = require("@tldraw/utils");
class AtomMap {
  constructor(name, entries) {
    this.name = name;
    const presentKeys = /* @__PURE__ */ new Set();
    const valueMap = /* @__PURE__ */ new Map();
    if (entries) {
      for (const [k, v] of entries) {
        presentKeys.add(k);
        valueMap.set(k, (0, import_state.atom)(`${name}:${String(k)}`, v));
      }
    }
    this.valueMap = valueMap;
    this.presentKeysAtom = (0, import_state.atom)(`${name}:presentKeys`, presentKeys);
  }
  valueMap;
  presentKeysAtom;
  /** @internal */
  getAtom(key) {
    const valueAtom = this.valueMap.get(key);
    if (!valueAtom) {
      this.presentKeysAtom.get();
      return void 0;
    }
    return valueAtom;
  }
  get(key) {
    const value = this.getAtom(key)?.get();
    (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
    return value;
  }
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.valueMap.get(key);
    if (!valueAtom) return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
    return value;
  }
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== import_state.UNINITIALIZED;
  }
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.valueMap.get(key);
    if (!valueAtom) return false;
    (0, import_utils.assert)(valueAtom.__unsafe__getWithoutCapture() !== import_state.UNINITIALIZED);
    return true;
  }
  set(key, value) {
    (0, import_state.transact)(() => {
      const existingAtom = this.valueMap.get(key);
      if (existingAtom) {
        existingAtom.set(value);
      } else {
        this.valueMap.set(key, (0, import_state.atom)(`${this.name}:${String(key)}`, value));
        this.presentKeysAtom.update((keys) => {
          const newKeys = new Set(keys);
          newKeys.add(key);
          return newKeys;
        });
      }
    });
    return this;
  }
  update(key, updater) {
    return (0, import_state.transact)(() => {
      const valueAtom = this.valueMap.get(key);
      if (!valueAtom) {
        throw new Error(`AtomMap: key ${key} not found`);
      }
      const value = valueAtom.__unsafe__getWithoutCapture();
      (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
      valueAtom.set(updater(value));
    });
  }
  delete(key) {
    return (0, import_state.transact)(() => {
      const valueAtom = this.valueMap.get(key);
      if (!valueAtom) {
        return false;
      }
      this.valueMap.delete(key);
      valueAtom.set(import_state.UNINITIALIZED);
      this.presentKeysAtom.update((keys) => {
        const newKeys = new Set(keys);
        newKeys.delete(key);
        return newKeys;
      });
      return true;
    });
  }
  deleteMany(keys) {
    return (0, import_state.transact)(() => {
      let newPresentKeys;
      const deleted = [];
      for (const key of keys) {
        const valueAtom = this.valueMap.get(key);
        if (!valueAtom) continue;
        const oldValue = valueAtom.get();
        (0, import_utils.assert)(oldValue !== import_state.UNINITIALIZED);
        deleted.push([key, oldValue]);
        this.valueMap.delete(key);
        valueAtom.set(import_state.UNINITIALIZED);
        if (!newPresentKeys) {
          newPresentKeys = new Set(this.presentKeysAtom.__unsafe__getWithoutCapture());
        }
        newPresentKeys.delete(key);
      }
      if (newPresentKeys) {
        this.presentKeysAtom.set(newPresentKeys);
      }
      return deleted;
    });
  }
  clear() {
    return (0, import_state.transact)(() => {
      for (const valueAtom of this.valueMap.values()) {
        valueAtom.set(import_state.UNINITIALIZED);
      }
      this.presentKeysAtom.set(/* @__PURE__ */ new Set());
      this.valueMap.clear();
    });
  }
  *entries() {
    this.presentKeysAtom.get();
    for (const [key, valueAtom] of this.valueMap.entries()) {
      const value = valueAtom.get();
      (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
      yield [key, value];
    }
  }
  *keys() {
    this.presentKeysAtom.get();
    for (const key of this.valueMap.keys()) {
      yield key;
    }
  }
  *values() {
    this.presentKeysAtom.get();
    for (const valueAtom of this.valueMap.values()) {
      const value = valueAtom.get();
      (0, import_utils.assert)(value !== import_state.UNINITIALIZED);
      yield value;
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.presentKeysAtom.get().size;
  }
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "AtomMap";
}
//# sourceMappingURL=AtomMap.js.map
