import { atom, transact, UNINITIALIZED } from "@tldraw/state";
import { assert } from "@tldraw/utils";
class AtomMap {
  constructor(name, entries) {
    this.name = name;
    const presentKeys = /* @__PURE__ */ new Set();
    const valueMap = /* @__PURE__ */ new Map();
    if (entries) {
      for (const [k, v] of entries) {
        presentKeys.add(k);
        valueMap.set(k, atom(`${name}:${String(k)}`, v));
      }
    }
    this.valueMap = valueMap;
    this.presentKeysAtom = atom(`${name}:presentKeys`, presentKeys);
  }
  valueMap;
  presentKeysAtom;
  /** @internal */
  getAtom(key) {
    const valueAtom = this.valueMap.get(key);
    if (!valueAtom) {
      this.presentKeysAtom.get();
      return void 0;
    }
    return valueAtom;
  }
  get(key) {
    const value = this.getAtom(key)?.get();
    assert(value !== UNINITIALIZED);
    return value;
  }
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.valueMap.get(key);
    if (!valueAtom) return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    return value;
  }
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== UNINITIALIZED;
  }
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.valueMap.get(key);
    if (!valueAtom) return false;
    assert(valueAtom.__unsafe__getWithoutCapture() !== UNINITIALIZED);
    return true;
  }
  set(key, value) {
    transact(() => {
      const existingAtom = this.valueMap.get(key);
      if (existingAtom) {
        existingAtom.set(value);
      } else {
        this.valueMap.set(key, atom(`${this.name}:${String(key)}`, value));
        this.presentKeysAtom.update((keys) => {
          const newKeys = new Set(keys);
          newKeys.add(key);
          return newKeys;
        });
      }
    });
    return this;
  }
  update(key, updater) {
    return transact(() => {
      const valueAtom = this.valueMap.get(key);
      if (!valueAtom) {
        throw new Error(`AtomMap: key ${key} not found`);
      }
      const value = valueAtom.__unsafe__getWithoutCapture();
      assert(value !== UNINITIALIZED);
      valueAtom.set(updater(value));
    });
  }
  delete(key) {
    return transact(() => {
      const valueAtom = this.valueMap.get(key);
      if (!valueAtom) {
        return false;
      }
      this.valueMap.delete(key);
      valueAtom.set(UNINITIALIZED);
      this.presentKeysAtom.update((keys) => {
        const newKeys = new Set(keys);
        newKeys.delete(key);
        return newKeys;
      });
      return true;
    });
  }
  deleteMany(keys) {
    return transact(() => {
      let newPresentKeys;
      const deleted = [];
      for (const key of keys) {
        const valueAtom = this.valueMap.get(key);
        if (!valueAtom) continue;
        const oldValue = valueAtom.get();
        assert(oldValue !== UNINITIALIZED);
        deleted.push([key, oldValue]);
        this.valueMap.delete(key);
        valueAtom.set(UNINITIALIZED);
        if (!newPresentKeys) {
          newPresentKeys = new Set(this.presentKeysAtom.__unsafe__getWithoutCapture());
        }
        newPresentKeys.delete(key);
      }
      if (newPresentKeys) {
        this.presentKeysAtom.set(newPresentKeys);
      }
      return deleted;
    });
  }
  clear() {
    return transact(() => {
      for (const valueAtom of this.valueMap.values()) {
        valueAtom.set(UNINITIALIZED);
      }
      this.presentKeysAtom.set(/* @__PURE__ */ new Set());
      this.valueMap.clear();
    });
  }
  *entries() {
    this.presentKeysAtom.get();
    for (const [key, valueAtom] of this.valueMap.entries()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield [key, value];
    }
  }
  *keys() {
    this.presentKeysAtom.get();
    for (const key of this.valueMap.keys()) {
      yield key;
    }
  }
  *values() {
    this.presentKeysAtom.get();
    for (const valueAtom of this.valueMap.values()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield value;
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.presentKeysAtom.get().size;
  }
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "AtomMap";
}
export {
  AtomMap
};
//# sourceMappingURL=AtomMap.mjs.map
